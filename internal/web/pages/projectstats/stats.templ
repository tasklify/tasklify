package projectstats

import (
	"tasklify/internal/handlers"
	"tasklify/internal/database"
	"tasklify/internal/web/pages"
	"net/http"
	"time"
	"tasklify/internal/web/components/common"
	"tasklify/internal/web/pages/task"
	"sort"
	"fmt"
	"math"
	"github.com/elliotchance/orderedmap/v2"
)

type StatsData struct {
	StoryPoints float64
	Realized    bool
	StartDate   time.Time
	EndDate     *time.Time
}

type ChartDataPoint struct {
	X string  `json:"x"`
	Y float64 `json:"y"`
}

type ChartSeries struct {
	Name string           `json:"name"`
	Data []ChartDataPoint `json:"data"`
}

func ProjectStats(w http.ResponseWriter, r *http.Request, params handlers.RequestParams) error {
	projectID := pages.GetProjectID(r)

	project, err := database.GetDatabase().GetProjectByID(projectID)
	if err != nil {
		return err
	}

	sprints, err := database.GetDatabase().GetSprintByProject(projectID)
	if err != nil {
		return err
	}

	statsData, err := getStatsDataRaw(sprints)
	if err != nil {
		return err
	}

	totalPoints, realizedPoints, err := getStatsData(statsData)
	if err != nil {
		return err
	}

	chartData, err := getStatsDataIntoChartData(totalPoints, realizedPoints)
	if err != nil {
		return err
	}

	user, err := database.GetDatabase().GetUserByID(params.UserID)
	if err != nil {
		return err
	}
	projectRoles, _ := database.GetDatabase().GetProjectRoles(params.UserID, projectID)

	c := stats(*project, projectRoles, user.SystemRole, chartData)
	return pages.Layout(c, "Stats", r).Render(r.Context(), w)
}

templ stats(project database.Project, projectRoles []database.ProjectRole, user_SystemRole database.SystemRole, chartData []ChartSeries) {
	@common.ProjectNavbar(project, projectRoles, user_SystemRole, "project_stats") {
		if len(chartData[0].Data) > 0 {
			<div class="min-h-screen">
				<div id="chart" class="w-3/4"></div>
			</div>
			@graph(chartData)
		} else {
			<div class="flex items-center justify-center min-h-screen">
				<p class="text-center mx-auto w-max text-2xl">
					No chart data to display
				</p>
			</div>
		}
	}
}

script graph(chartData []ChartSeries) {
	var startDate = chartData[0].data[0].x; // First date in the first series
	var endDate = chartData[0].data[chartData[0].data.length - 1].x; // Last date in the first series

	console.log(startDate, endDate)

	var options = {
		series: chartData,
          chart: {
          height: 500,
          type: 'area',
		  zoom: {
            autoScaleYaxis: false
          },
        },
        stroke: {
       //   curve: 'smooth'
        },
        xaxis: {
			type: 'datetime',
		//	min: new Date(startDate).getTime(), // Sets the minimum boundary
        //	max: new Date(endDate).getTime(), // Sets the maximum boundary
        },
        tooltip: {
          x: {
            format: 'yyyy-MM-dd'
          },
        },
	}

	// Get the chart container element
	var chartContainer = document.querySelector('#chart');

	// Function to clear all child elements from a node
	function clearNode(node) {
		while (node.firstChild) {
			node.removeChild(node.firstChild);
		}
	}

	// Check if the chart container exists, clear it and render the chart
	if (chartContainer) {
		clearNode(chartContainer);

		// Create and render the chart
		var chart = new ApexCharts(chartContainer, options);
		chart.render();
		//console.log({ realizedPoints });
	} else {
		console.log("Chart container not found.");
	}
}

func getStatsDataRaw(sprints []database.Sprint) ([]StatsData, error) {
	var statsData []StatsData
	for _, sprint := range sprints {
		if database.StatusTodo != sprint.DetermineStatus() {
			userStories, err := database.GetDatabase().GetUserStoriesBySprint(sprint.ID)
			if err != nil {
				return nil, err
			}

			for _, userStory := range userStories {

				tasks, err := database.GetDatabase().GetTasksByUserStory(userStory.ID)
				if err != nil {
					return nil, err
				}

				var userStoryWorkSessions []database.WorkSession
				for _, task := range tasks {

					workSessions, err := database.GetDatabase().GetWorkSessionsForTask(task.ID)
					if err != nil {
						return nil, err
					}

					userStoryWorkSessions = append(userStoryWorkSessions, workSessions...)
				}

				userStoryWorkSessions = task.SortWorkSessionsByDate(userStoryWorkSessions)

				var realized bool

				realizedTemp := userStory.Realized
				if realizedTemp != nil {
					realized = *realizedTemp
				}

				temp := StatsData{
					StoryPoints: userStory.StoryPoints,
					Realized:    realized,
					StartDate:   sprint.StartDate,
				}

				if realized {
					temp.EndDate = userStoryWorkSessions[len(userStoryWorkSessions)-1].EndTime
				}

				statsData = append(statsData, temp)
			}
		}
	}

	return statsData, nil
}

func getStatsData(statsDataRaw []StatsData) (totalPoints, realizedPoints *orderedmap.OrderedMap[time.Time, float64], err error) {
	sort.Slice(statsDataRaw, func(i, j int) bool {
		return statsDataRaw[i].StartDate.Before(statsDataRaw[j].StartDate)
	})

	/*
		startDate := statsDataRaw[0].StartDate
		endDate := time.Now().Truncate(24 * time.Hour) // Use current day as the end point
	*/

	totalPoints = orderedmap.NewOrderedMap[time.Time, float64]()
	realizedPoints = orderedmap.NewOrderedMap[time.Time, float64]()
	currentTotalPoints := 0.0
	currentRealizedPoints := 0.0

	for _, d := range statsDataRaw {
		currentTotalPoints += d.StoryPoints
	}

	currentRealizedPoints = currentTotalPoints

	// Calculate total story points added and realized up to each date
	for i, d := range statsDataRaw {
		totalPoints.Set(d.StartDate, currentTotalPoints)

		// Have first day synced
		if i == 0 {
			realizedPoints.Set(d.StartDate, currentRealizedPoints)
		}

		if d.Realized && d.EndDate != nil {
			currentRealizedPoints -= d.StoryPoints
			realizedPoints.Set(*d.EndDate, currentRealizedPoints)
		}

		// Sync last day
		if i == len(statsDataRaw)-1 {
			totalPoints.Set(time.Now(), currentTotalPoints)
			realizedPoints.Set(time.Now(), currentRealizedPoints)
		}

		currentTotalPoints -= d.StoryPoints
	}

	// Ensure every day has an entry in the maps
	/*
		for date := startDate; !date.After(endDate); date = date.AddDate(0, 0, 1) {
			if _, exists := totalPoints[date]; !exists {
				totalPoints[date] = currentTotal
			}
			if _, exists := realizedPoints[date]; !exists {
				realizedPoints[date] = 0
			}
		}
	*/

	return
}

func getStatsDataIntoChartData(totalPoints, realizedPoints *orderedmap.OrderedMap[time.Time, float64]) ([]ChartSeries, error) {
	var actualSeriesData []ChartDataPoint
	var expectedSeriesData []ChartDataPoint

	sortedTotalKeys := totalPoints.Keys()
	sort.Slice(sortedTotalKeys, func(i, j int) bool {
		return sortedTotalKeys[i].Before(sortedTotalKeys[j])
	})

	for _, date := range sortedTotalKeys {
		points, ok := totalPoints.Get(date)
		if !ok {
			return nil, fmt.Errorf("totalPoints.Get(date)", date)
		}

		parsedDate := date.Format(time.DateOnly)
		actualSeriesData = append(actualSeriesData, ChartDataPoint{X: parsedDate, Y: roundToTwoDecimals(points)})
	}

	sortedRealizedPoints := realizedPoints.Keys()
	sort.Slice(sortedRealizedPoints, func(i, j int) bool {
		return sortedRealizedPoints[i].Before(sortedRealizedPoints[j])
	})

	for _, date := range sortedRealizedPoints {
		points, ok := realizedPoints.Get(date)
		if !ok {
			return nil, fmt.Errorf("realizedPoints.Get(date)", date)
		}

		parsedDate := date.Format(time.DateOnly)
		expectedSeriesData = append(expectedSeriesData, ChartDataPoint{X: parsedDate, Y: roundToTwoDecimals(points)})
	}

	actualSeries := ChartSeries{Name: "Actual Story Points", Data: actualSeriesData}
	expectedSeries := ChartSeries{Name: "Expected/remaining Story Points", Data: expectedSeriesData}

	chartData := []ChartSeries{actualSeries, expectedSeries}

	return chartData, nil
}

// roundToTwoDecimals rounds a float64 to two decimal places.
func roundToTwoDecimals(num float64) float64 {
	factor := 100.0
	return math.Round(num*factor) / factor
}
